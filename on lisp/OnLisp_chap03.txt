;; 『On Lisp』のコード例のなかから、興味深いものをピックアップして、
;; 「Clojure で実現するとこんな感じかな？」というコードを書いてみました。

==================================
3.1 関数型のデザイン (P29-34)
==================================

(defn good-reverse [lst]
　(letfn [(rev [lst acc]
　　(if (empty? lst)
　　　acc
　　　(recur (rest lst) (cons (first lst) acc))))]

　　(rev lst ())))

(defn my-trancate [n]
  {:int (int n) :frac (rem n 1)})

;; user=> (my-trancate 26.21875)
;; {:int 26, :frac 0.21875}

----------------------------------

(defn my-powers [n]
　[n (Math/sqrt n) (Math/pow n 2)])

;; user=> ((fn [[b r s]]
;; 　{:base b :root r :square s}) (my-powers 4))
;;   #_=> {:base 4, :root 2.0, :square 16.0}


==================================
3.2 命令型プログラミングの裏返し (P34-36)
==================================

;; [ 命令型 ]

(defn imp [x]
　(let [ y (atom 0) sqr (atom 0) ]
　　(reset! y (first x))
　　(reset! sqr (Math/pow @y 2))
　　(list 'a @sqr)))

;; [ 関数型 ]

(defn fun [x]
　(list 'a (Math/pow (first x) 2)))


==================================
3.3 関数型インターフェース (P36-38)
==================================

;; …うーん、説明がよく分からないんだよなぁ、この節。

;; 本文中にある「Lispの（関数呼び出しの）慣習」とは？
;; ・　返り値を「支配する」
;; ・　引数を「支配しない」（引数に変更を加える「破壊的」な関数はなるべく用いるな、ということか？）

;; 呼び出される関数は、このような作りにしろ、と。
;; ただ、実際には多くのプログラムがこの「慣習」を逸脱しているけれどね、と。

----------------------------------

;; [ 要するに ]

;; ①　（自身の書いている）関数内の処理で、十分に気をつけて「破壊的」な関数を用いることはあるよ、と。
;; ②　（自身の書いている）関数内の処理で、グローバル変数のたぐいを用いるな（引数として渡されるようにしろ、と）。

;; これら①、②を満たしていたら、その関数は「関数型インターフェース」を提供していることになる、と。
;; つまり、「関数型プログラミングに則ったコードの一員です」といっぱしの顔しているだろう、と。

----------------------------------

;; 以下のようにすると、
;; Clojure でも、「関数型インターフェース」を持たない関数を書くことが可能だ。

　・関数内部でグローバル変数を参照しない
　・引数を書きかえない（その値をコピーして利用するべき）

----------------------------------

;; [ not-ok：引数を変更している ]

(defn my-inc [n]
　(reset! n (inc @n)))

(defn my-inc [n]
　(let [v (identity n)]
　　(reset! v (inc @n))
　　v))

(def val1 (atom 0))

user=> @val1
0
user=> (my-inc val1)
1
user=> @val1
1

----------------------------------

;; [ ok：引数を変更していない（返り値を生成している） ]

(defn my-inc-safe [n]
　(atom (inc @n)))

(def val2 (atom 0))

user=> @val2
0
user=> @(my-inc-safe val2)
1
user=> @val2
0


==================================
3.4 インタラクティブ・プログラミング (P39-40)
==================================

;; [ 要するに ]

関数型プログラミングは、

　・　引数以外を参照しない、
　・　返り値をとおしてのみ、外部に影響をおよぼす。
　・　関数の目的は、自然とひとつに限定される。

これは、プログラムの構成として良い方法だ。
そして、それは美的にも美しいが、でもそれだけのものじゃない。
以下のようなメリットがある。

　・　上記のルールを原則とすれば、それを逸脱する箇所を限定できる。
　　逸脱する場合であっても、「3.3 関数型インターフェース」を適用するようになる。
　・　速く書ける。
　・　デバッグ、テストすることが容易であるため、頻繁に動作を確認できるため、信頼性が高い（「並外れて」）。
　
これらを繰り返すことで、

　・プログラミング言語を拡張できる。
　・その拡張部は、信頼できるものである（そうする責任を負わなくてはならない）。
　・その拡張した言語で、プログラムを（楽に）書けるようになる。

このように作られた抽象的構造が、「ボトムアップ」デザインの礎となる、と。


==================================
