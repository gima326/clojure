;; 『プログラミング Clojure』（第二版）の「第７章　マクロ」の記述を読み返しながら、
;; その目線で『On Lisp』の chapter 07 - 10 の内容をふり返る。

=====================================

『On Lisp』で出てきた用語、重要なフレーズをあらためて。

　「第 7 章　マクロ」

　　・「マクロ展開」：　
　　　新しい式を生成する工程。マクロ展開後、つぎの工程で生成された式（展開形）を評価する。

　　・「展開」：　
　　　関数内でのマクロ呼び出しは、関数がコンパイルされたときに展開される。

　　・「展開形」：　
　　　その関数が呼び出されるまで、展開された式は評価されない。

　　・「展開コード」(expander code)：　
　　　マクロが展開形を生成するために使うコード。効率よりも明確さを優先すべき。

　　・「被展開コード」(expansion code)：　
　　　展開形そのものに現れるコード。明確さよりも効率を優先すべき。

　　・「マクロの効率性」：
　　　マクロはどこででも使われるもので、しかも、マクロは不可視である。
　　　展開形の非効率性が明るみになりにくい。


　　・マクロ展開は「式」を扱う。
　　・評価は（その式の）「値」を扱う。
　　・パーサがソースを読んで、（Lisp のオブジェクトのリストからなる）出力をコンパイラに送る。
　　・マクロは、パーサとコンパイラの間の「中間形式」の状態のときの出力を操作する。
　　・コンパイラが読む情報を書きかえる操作にあたる。
　　・コンパイラが読む情報を書きかえる操作は、コンパイラを書き換えられる、と換言できる。

----------------------------------

　「第 8 章　いつマクロを使うべきか」

　　　〜マクロの長所〜

　　　　１．コンパイル時の計算（実行時のオーバーヘッドのうちのいくらかを、コンパイル時に済ませておける）
　　　　２．Lisp との密な統合（「車輪の再実装」を避けられる）
　　　　３．関数呼び出しの節約（地のコードに変換されるマクロは、関数と違い呼び出しコストがない）

　　　〜マクロの短所〜

　　　　４．関数に出来ることのうち、いくつかは不可能（関数はデータだが、マクロはコンパイラへの指示にちかいもの）
　　　　５．ソースコードの不明確さ（関数の定義より読みづらい）
　　　　６．実行時の不明確さ（デバッグしづらい、とか）
　　　　７．再帰がめんどう（関数ほど楽じゃない）


　　・マクロは、マクロ呼び出し内の引数の評価を、以下の 4 通りの方法で制御する。

　　　１．変形
　　　２．変数束縛
　　　３．条件分岐による評価
　　　４．複数回の評価

　　・また、マクロのインライン展開も以下のような活用ができる（変数捕捉に気をつけよう）。

　　　５．呼び出し側の環境を利用する
　　　６．新しい環境を包み込む
　　　７．関数呼び出しを節約する


　　・「ユーティリティー」から「埋め込み言語」の実装まで、マクロの応用範囲は幅広い。

　　・「ユーティリティー」：
　　　最下層の Lisp の上に加える「層」、文字数減らし、パターンの統合など

　　・「埋め込み言語」：
　　　・特別な用途を持っている
　　　・「ユーティリティー」よりも大がかりなもの
　　　・「リスト」として表現された式であれば、それが Lisp でなくても、
　　　　Lisp 自身が備えている組み込みパーザ（read）、コンパイラー（compiler）を用いて、
　　　　その式を「言語」として扱うことができる

　　　・プログラムは、その「埋め込み言語」（の文法）で書かれたものと、Lisp の文法とが混在した状態になる
　　　・既存の Lisp の機能を利用できる（必要な機能のすべてを自作する必要はない）
　　　・「埋め込み言語」実装方法は、２タイプ（インタプリタータイプ、コンパイラータイプ）

　　　　「インタプリタータイプ」：
　　　　　・素朴な方法である
　　　　　・Lisp の組み込みパーザ（read）を利用する
　　　　　・「組み込み言語」の文法を解釈・評価するためのインタプリタを作る
　　　　　・実行時に、「組み込み言語」インタプリタが「埋め込み言語」部分を解釈・評価する
　　　　　・そのつど解釈される（オーバーヘッドになる）
　　　　　・遅い

　　　　「コンパイラータイプ」：
　　　　　・より良い方法である
　　　　　・Lisp の組み込みコンパイラー（compiler）を利用する
　　　　　・コンパイル時に、コンパイラーが「埋め込み言語」の個々の式を、
　　　　　　インタプリタが「埋め込み言語」部分を解釈・評価するのと同じ動作をする Lisp コードに変換する
　　　　　・実行時の解釈のオーバーヘッドがない
　　　　　・速い

----------------------------------

　「第 9 章　変数捕捉」

　　・マクロの弱点は、変数捕捉だ。
　　・変換済みのコードに含まれるあるシンボルが、別のコンテキストにある、同名の変数を参照してしまうときに起こる。
　　・どんなシンボルが変数捕捉を起こすか見極めるには経験が要る。そして、以下のキーワードで判断できる。

　　　・「自由」
　　　・「骨格」
　　　・「捕捉可能」性

　　・変数捕捉なんてめったに起こらない、などと考えるなかれ。
　　・マクロが不適切に展開された場合に備えた「防衛策」をとっておいて損はない。
　　・そのマクロの「使用者」はプログラムかもしれない。

----------------------------------

　「第 10 章　マクロのその他の落とし穴」

　　・マクロの作者は関数とはちがう、以下のような苦労がある。

　　　１．評価を制御できるマクロは、評価されるその回数まで明確に把握する。
　　　２．評価を制御できるマクロは、評価の順番を明確に把握する。
　　　３．マクロ展開を生成するコードは、純粋な関数型であるべき。
　　　４．（関数のときのような）自分自身を呼び出すタイプの再帰は不可能。

----------------------------------

『プログラミング Clojure』の説明で出てきた用語と、重要なフレーズを付記。

　・「特殊形式」（『On Lisp』でも「後注」で説明している。P398）
　・「カプセル化」

　　・特殊形式は、言語における「特異点」である。
　　・特殊形式の特殊性は、コードの繰り返しを多くし、保守を難しくする原因となる。
　　・Java の特殊形式は、それぞれが独自の構文を持っている（たとえば if、new など多数）。
　　・Clojure の特殊形式は、単なる Clojure のデータ構造である。

　　・Clojure は、コードにたいして特別な構文を用意していない。
　　・ふつうの関数呼び出し、特殊形式、マクロについても、Clojure のコードはデータ構造によって作られる。
　　・特殊形式は、プログラマにはない「特別な力」を有している。

　　・（広義の抽象化を表す用語としての）「カプセル化」を阻むパターンの多くが「特殊形式」のまわりで起きる。

　　・マクロは特殊形式を生成できる。
　　・特殊形式を生成するマクロを書くのはたいへんだが、その効果はきわめて大きい。
　　・特殊形式を生成するマクロは、言語に新たな機能を追加することを可能にする（「魔法のように」）。

　　・Clojure における特殊形式は関数ではない（言語の「第一級市民」ではない）。
　　・Clojure の特殊形式は、関数に出来ることのいくつかが不可能である。
　　・すべての言語機能は、マクロ展開時には「第一級の機能」である。
　　・マクロ呼び出しは、呼び出し側に簡便さをもたらす。

=====================================

(defmacro me [expr]
　`(pprint (macroexpand '~expr)))

(defmacro me1 [expr]
　`(pprint (macroexpand-1 '~expr)))

(defmacro bench [expr & flg]
　`(let [start# (System/nanoTime) result# ~expr]
　　　result#
　　　{ :result (if ~@flg result# ~''----)
　　　　:elapsed (- (System/nanoTime) start#) }))

=====================================
7.1 いつマクロを使うべきか (P161)
=====================================

;; 「マクロ・クラブ」へようこそ

;; ルール：２つ
　・マクロは書くな
　・パターンをカプセル化する唯一の方法なら、マクロを書け（「特殊形式のルール」と呼ぶことも）

;; 例外：１つ
　・同等の関数に比べて、呼び出し側が楽になるのなら、マクロを書いても構わない


=====================================
7.2 フロー制御のマクロを書く (P162-168)
=====================================

;; 欲しいオペレータをいきなり自作するのではなく、まずは、
;; すでにそれが存在しないか調べよう、と。

;; ここでは車輪の再実装をば。
;; 「when-not」を参考に Clojure の特殊形式「if」と反対の挙動をする、
;; オペレータ「unless」をマクロで実装してみることに。

----------------------------------

user=> (source when-not)
(defmacro when-not
  "Evaluates test. If logical false, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
    (list 'if test nil (cons 'do body)))
nil

----------------------------------

;; 組み込みオペレーター「when-not」と同じ動作をするものだけど、
;; 単純なマクロでもこれほど多くのパターンで書けるんだなぁ、と（文字数が少ないものから並べてみる）。

(defmacro unless [test & body]
　`(if ~test nil (do ~@body)))

(defmacro unless2 [test & body]
　`(if (not ~test) (do ~@body)))

(defmacro unless3 [test & body]
　`(if ~test nil ~(cons 'do body)))

(defmacro unless4 [test & body]
　`(if (not ~test) ~(cons 'do body)))

(defmacro unless5 [test & body]
　(list 'if `(not ~test) (cons 'do body)))

(defmacro unless6 [test & body]
　(list 'if (list 'not test) (cons 'do body)))

----------------------------------

user=> (def cnt (atom 0))
#'user/cnt

user=> (me (unless (>= @cnt 10) (println @cnt) (swap! cnt inc)))
(if (>= @cnt 10) nil (do (println @cnt) (swap! cnt inc)))
nil

user=> (me (unless2 (>= @cnt 10) (println @cnt) (swap! cnt inc)))
(if (clojure.core/not (>= @cnt 10)) (do (println @cnt) (swap! cnt inc)))
nil

----------------------------------

;; バグあり「unless-bug」（同じタイプの正常版は「unless5、6」）

(defmacro unless-bug [test & body]
　(list 'if (not test) (cons 'do body)))


;; 引数「test」に nil 以外の式、値が渡されると、if の条件部は常に false になる。

user=> (me (unless-bug (>= @cnt 10) (println @cnt) (swap! cnt inc)))
(if false (do (println @cnt) (swap! cnt inc)))
nil

user=> (me (unless-bug nil (println @cnt) (swap! cnt inc)))
(if true (do (println @cnt) (swap! cnt inc)))
nil


=====================================
7.3 マクロを簡単にする (P168-173)
=====================================

;; バグを入れこんだやつ。

(defmacro bench-bug [expr & flg]
　`(let [~'start (System/nanoTime) ~'result ~expr]
　　　~'result
　　　{ :result (if ~@flg ~'result ~''----)
　　　　:elapsed (- (System/nanoTime) ~'start) }))


;; バグはあるけど、ちゃんと動作する場合もあるよ、と。

user=> (let [a 1 b 2] (bench-bug (+ a b) true))
{:result 3, :elapsed 29441}

----------------------------------

;; [ 引数「expr」の式に、変数「start」を含めてみる：バグ出る ]

user=> (let [a 1 b 2 start 3] (bench-bug (+ a b start) true))
{:result 1411754087528567, :elapsed 24582}

----------------------------------

;; def、let で束縛した start が、マクロ内部の let* で処理開始時間として再束縛され、
;; それが足し算の対象になっていることが分かる。

user=> (def a 1)
#'user/a

user=> (def b 2)
#'user/b

user=> (def start 3)
#'user/start

user=> (me (bench-bug (+ a b start) true))
(let*
 [start (java.lang.System/nanoTime) result (+ a b start)]
 result
 {:result (if true result '----),
  :elapsed (clojure.core/- (java.lang.System/nanoTime) start)})
nil


=====================================
7.4 マクロの分類学 (P173-181)
=====================================

　・条件的な評価：
　　　when、and、or、comment

　・var の定義：
　　　def、defn、defmacro、defmulti

　・Java の呼び出し：
　　　new、..、doto

　・評価の遅延：
　　　lazy-cat、lazy-seq、delay

　・評価を包む（呼び出し側に負担を強いる lambda を省略する、など）：
　　　with-open、dosync、with-out-str、time、assert

=====================================
7.5 まとめ (P181)
=====================================

　Lisp の「マクロ」は、

　　・コードにあらわれる「パターン」をより良く統合（抽象化）する
　　・抽象化した「パターン」は、自動的に地のコードに変換する
　　・ソースコードをマクロ展開時に変換する
　　・言語を問題領域に合わせて拡張する柔軟性を提供する

　　・プログラマを言語の中から解放する

　という。


=====================================
